---
title: "FGCZ Two-Group Analysis \n Statistics for a Quantitative Protein Matrix"
author: "Functional Genomics Center Zurich"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    toc: true
  bookdown::html_document2:
    toc: true
  pdf_document: 
    toc: true
header-includes: 
  \usepackage{fancyhdr}
  \pagestyle{fancy}
  \fancyhead[CO,CE]{Group Comparison}
  \fancyfoot[CO,CE]{\textbf{FGCZ} - www.fgcz.ch - 2018}
  \fancyfoot[LE,RO]{\thepage} 
params:
  #grp: !r quote(SRMService::mqQuantMatrixGRP2)
  grp: NULL
vignette: >
  %\VignetteIndexEntry{FGCZ Two-Group Analysis}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
bibliography: bibliography.bib
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE
)

if (!exists("progress")) {
  progress <- function(howmuch, detail){
    invisible(NULL)
  }
}

grp2 <- params$grp
```

# Introduction

The following analysis compares protein intensities recorded in two groups of samples (Tables \@ref(tab:samples) and \@ref(tab:annotation)) by computing the $log_2$ fold change $\log_2(condition/reference)$, and tests if they are non-zero.

The protein identification and quantification were performed using `r grp2$Software`. The outputs are available in b-fabric [`r GRP2$inputID`](`r GRP2$inputURL`).

We run a set of functions implemented in the R package _prolfqua_ [@wolski2020prolfqua] to generate visualizations, normalize the data and to compute _moderated t-statistics_[@Smyth2004], p-values and false discovery rates (FDR) for all proteins quantified.

## Experiment summary

This report is stored in the LIMS system _bfabric_ <https://fgcz-bfabric.uzh.ch> [@Trker2010] in the project `r grp2$projectID`, order `r grp2$orderID`, `r if(!is.null(grp2$workunitID)){ "with the workunit name :" }`  `r grp2$workunitID`.


The protein matrix is filtered using the following threshold:
- Minimum number of peptides / protein: `r grp2$nrPeptides`.


- The total number of proteins in this experiment is: `r grp2$totalNrOfProteins` 
- Total number without decoys sequences is `r grp2$NrOfProteinsNoDecoys` 
- Percentage of contaminants : `r grp2$percentOfContaminants` %
- Percentage of false positives : `r grp2$percentOfFalsePositives` %


```{r samples, eval=TRUE}

tab <- data.frame(table(grp2$lfqData$factors()[[grp2$lfqData$config$table$fkeysDepth()]]))
colnames(tab) <- c("Condition","# samples")
knitr::kable(tab, caption = "Nr of samples in each condition.")

```

Table \@ref(tab:samples) shows the number of samples in each condition while Table \@ref(tab:annotation) shows the raw files assigned to the conditions.

```{r annotation, eval=TRUE}
knitr::kable(grp2$lfqData$factors(), caption = "Condition sample mapping.")

```


<!--
The input matrix has the following structure (Figure \@ref(fig:overview)).

```{r overview, fig.width=8,fig.height=7,dpi=300,fig.cap="Heatmap for quantifyable #proteins sorted by missigness and intensity (log2). Gray - missing values"}
#imageWithLabels(t(log2(grp2$proteinIntensity)), col.labels = NULL, #col=quantable::getBlueScale(21))
```
-->


\newpage

# Quality Control

## Missing Data and Intensity Distribution

Figure \@ref(fig:missingValuesPerProtein) A shows the number of proteins (y) axis with $0-N$ missing values (x - axis), while
the histogram on the left (Panel B) shows the distribution of intensities of proteins with $0-N$ missing values.

```{r histmissing, eval=FALSE }
```


```{r missingValuesPerProtein, eval=TRUE, fig.cap="Panel A - # of proteins with n missing values, Panel B - intensity distribution of proteins with 1 to N missing values.", fig.height=5, fig.width=8}

pl <- grp2$lfqData$get_Plotter()
p2 <- pl$missigness_histogram()

sr <- grp2$lfqData$get_Summariser()
p1 <- sr$plot_missingness_per_condition()

gridExtra::grid.arrange(p1,p2, nrow=1)

progress(0.1, "Summary")
```

Shown in Figure \@ref(fig:distributionRaw) are the distributions of raw log2 transformed protein intensity values for each sample. Ideally the violins should look very similar (have the same shape and span the same intensity range).

```{r distributionRaw, fig.width=8, fig.height=5, fig.cap="Violin plots for quantifyable proteins (log2 transformed)", eval= TRUE}
pl$intensity_distribution_violin() +  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))

```

In Figure \@ref(fig:scaling) the $\log_2$ fold change of the average sample intensity versus the mean average intensity of all samples is shown. It is critical if a samples average deviates more than 5 times from the average of all samples (linear scale).

```{r  scaling,dpi=300, fig.height=6, fig.cap="Average intensity in sample vs average intensity in all samples. red line - critical fold change.", eval= TRUE}
xb <- grp2$lfqData$data |> 
  group_by(!!sym(grp2$lfqData$config$table$sampleName)) |>
  summarize(median = median(!!sym(grp2$lfqData$config$table$getWorkIntensity())))

bb <- xb$median
names(bb) <- xb$sampleName
par(mar = c(10,6,3,6))
barplot(sort(abs(log2(bb)))  - mean(log2(bb)) ,
        horiz = F,las = 2, main = "median", cex.names = 0.6, ylab = "sample avg. - total avg. (log2 intensities)", ylim = c(-log2(8),log2(8)))
abline(h = c(-log2(5),log2(5)), col = 2)
x <- seq(-3 ,3 ,by = 1)
axis(4,x,round(2^abs(x),digits = 1))
mtext("linear scale", side = 4, line = 2)
```



```{r progress2, eval=FALSE}
progress(0.2, "Normalization")
```

## Normalization

Figure \@ref(fig:normalized) shows the normalized values. Normalization is applied to remove systematic differences in protein abundance due to different sample concentrations, or different amount of sample loaded on column. Normalization is important, so that true differentially expressed proteins can be detected. To do this the z-score of the log2 transformed intensities is computed, which is updated by the average of the standard deviation of the log2 transformed intensities in all samples. After normalization all samples have an equal mean and variance and a similar distribution.


```{r normalized,  fig.width=8, fig.height=5,dpi=300, fig.cap="Violin plots of normalized protein intensity values (z-score)", eval=TRUE}
pl <- grp2$transformedlfqData$get_Plotter()
pl$intensity_distribution_violin() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
```

\pagebreak


The left panel of Figure \@ref(fig:SDViolin), show the coefficient of variations (CV) for all proteins in each condition and overall computed on not normalized data. To observe differences between conditions the variation within a condition should ideally be smaller than within all conditions.


```{r CViolin, eval=FALSE}

```

The right panel of Figure \@ref(fig:SDViolin) shows the distributions of standard deviations (sd) for all proteins within the conditions and overall after transforming and scaling the data. To observe differences between conditions the standard deviation within a condition ideally should be smaller than within all conditions.  

```{r SDViolin, fig.height=3, fig.width=7, fig.cap="Left panel - Distribution of protein CV within conditions and in entire experiment (all), Right panel - Distribution of protein standard deviation (after sample normalization and scaling) within conditions and in entire experiment.", eval=TRUE}

stR <- grp2$lfqData$get_Stats()
p1 <- stR$violin()

st <- grp2$transformedlfqData$get_Stats()
p2 <- st$violin()
gridExtra::grid.arrange(p1,p2, nrow=1)

```

```{r, eval=TRUE}
resR <- stR$stats_quantiles()
res <- st$stats_quantiles()

C <- bind_rows(
CV = resR$wide  |> filter(probs == 0.5),
sd = res$wide |> filter(probs == 0.5))
C <- C |> mutate( what = c("CV","sd"), .before = 1 )


knitr::kable(C, caption = 'median of cv and sd')

progress(0.1, "CVs")

```


## Clustering for Samples and Proteins

```{r generateHeatmaps, inlcude = FALSE}
pl <- grp2$transformedlfqData$get_Plotter()
ph <- pl$heatmap()
phc <- pl$heatmap_cor()
nah <- pl$NA_heatmap()
```

```{r correlation, dpi=300, fig.height=5, fig.width=7, fig.cap="Heatmap of correlations (spearman) between samples.", eval=TRUE}
phc
```

In Figure \@ref(fig:correlation) and Figure \@ref(fig:heatmapData) we show how samples are clustering depending on the spearman correlation. Side colors on top of the heatmaps indicate the grouping variables. Figure \@ref(fig:heatmapData) shows the heatmap of the dataset; columns correspond to samples, while rows to proteins. The rows are z-transformed, i.e. each row has the same mean and standard deviation. Finally, in the heatmap figure \@ref(fig:heatmapNA), we show in black if a protein is missing in a sample. Some experiments switch off the expression of a group of proteins and this can be potentially be spotted in this figure. The samples and proteins are clustered based on the missigness information using the Minkowski distance.



```{r heatmapData, fig.width=7, fig.height=8, dpi=300, fig.cap="Heatmap of normalized data. Columns - samples, rows - proteins. The intensities of each protein are z-transformed.", eval=TRUE}
ph
```

```{r heatmapNA, fig.width=7, fig.height=8, dpi=300, fig.cap="Heatmap of proteins containing missing values, white - present, black - basent.", eval=TRUE}
nah
```




# Two Group Comparison

We fit a linear model, which was specified using the following model formula:

`r grp2$formula`,

where `<response variable> ~ <explanatory variables>`.

Using the linear model we compare the following two conditions and test for differential expression.

`r names(grp2$Contrast)` = `r grp2$Contrast`.

For some of the proteins the linear model can not be fitted because there are no observations in one of the conditions. Assuming that the observation are missing in a condition because the protein abundance is below the limit of detection, we impute the unobserved condition average using the mean of $1\%$ smallest group averages in the sample. 
The proteins for which a linear model can be fitted are labelled with `Linear_Model_Moderated`, while those proteins were we imputed the missing group mean are labelled with `Imputed_Condition_Mean`.

The following analysis assumes that most of the proteins are not regulated (most differences between the two conditions should be close to zero, and only a few proteins are differentially expressed. Figure \@ref(fig:densityOFFoldChanges), left panel, shows the distribution of fold changes. Again, most of the fold changes should be close to zero, and also the median of all fold changes (red dashed line) should be close to zero (green line).

Based on the model coefficients, we estimate the difference between the conditions and the variance for each protein, which allows us to compute the t-statistic. Furthermore, using the degrees of freedom, we determine the p-value, i.e., the probability of the type I error, i.e., the error of falsely rejecting the null hypothesis. The null hypothesis is that proteins are not differentially expressed. The right panel in Figure \@ref(fig:densityOFFoldChanges) shows the distribution of the p-values for all the proteins. However, when testing the differential expression of many proteins, the p-value does not control the type I error. Therefore, based on the distribution of the p-values, we estimate the false discovery rates (FDR), the expected proportion of false discoveries in a list of proteins filtered by FDR. 

Figure \@ref(fig:volcanoplot) plots the $-\log_{10}(FDR)$ against the difference in the two conditions. Significant calls are made with FDR smaller than `r grp2$FDRthreshold` and $log_2$ fold change greater than `r grp2$log2FCthreshold` (see Figure \@ref(fig:volcanoplot)). Figure \@ref(fig:MAPlot) shows the difference among the experiments (y-axis) and the average intensity of the protein (x-axis), and e.g., can be used to identify abundant proteins with a large difference.


(ref:densityOFFoldChanges) Top : Distribution of differences among experiments. Bottom - histogram of p-values.


```{r densityOFFoldChanges, fig.width=8, fig.height=4, dpi=300, fig.cap = "(ref:densityOFFoldChanges)"}
p1 <- grp2$contrMerged$histogram_diff()
p2 <- grp2$contrMerged$histogram()$p.value
gridExtra::grid.arrange(p1,p2)

```

\newpage

(ref:volcanoplot) Volcano plot where the x-axis shows the difference among the experiments and the y-axis the $-\log_10(FDR)$.

```{r volcanoplot, fig.width=8, fig.height=5, fig.cap="(ref:volcanoplot)", eval=TRUE}
grp2$contrMerged$volcano_plotly()$FDR

```


(ref:MAPlot) MA plot: x - axis: mean normalized protein intensity, y - axis: difference between the conditions.

```{r MAPlot, fig.width=8, fig.height=5,  fig.cap="(ref:MAPlot)", eval=TRUE}
grp2$contrMerged$ma_plotly(fc = GRP2$log2FCthreshold)

```

Table \@ref(tab:nrsignificant) summarizes the number of significant calls, while \@ref(tab:top20table) lists the 20 proteins with the smallest FDR.


```{r nrsignificant, results="markup", eval=TRUE}

x <- data.frame(table(abs(grp2$contrMerged$contrastDF$diff) >  grp2$log2FCthreshold  & grp2$contrMerged$contrastDF$FDR < grp2$FDRthreshold))

if (length(x$Var1) == 2) {
  x$Var1 <- c("Not Significant" , "Significant")
  names(x)[names(x) == 'Var1'] <- ''
}

mycap <- paste0("Number of not significant and significant proteins with abs(log2_FC) > ", grp2$log2FCthreshold, " and FDR < ", grp2$FDRthreshold, "."  )
knitr::kable(x, caption = mycap)
```



```{r top20table, eval=TRUE}
knitr::kable(grp2$top20, caption = "Top 20 proteins sorted by smallest FDR.")
```


```{r prepareHeatmap}

significant <- grp2$contrMerged$contrastDF |>
  dplyr::filter(.data$FDR < grp2$FDRthreshold & abs(.data$diff) > grp2$log2FCthreshold )

signif <- grp2$transformedlfqData$get_copy()
signif <- signif$get_subset(significant)
showSignificant <- TRUE

if (nrow(signif$data) > 0) {
  sigheat <- signif$get_Plotter()$raster()
} else {
  showSignificant <- FALSE 
}

nrb <- 0

```


```{r getBoxplots, eval = showSignificant}

pl <-  signif$get_Plotter()
bp <- pl$boxplots()$boxplot
nrb <- min(length(bp), 6)
bp <- bp[seq_len(nrb)]
```


```{r makeText, eval = showSignificant, results = 'asis'}

cat(paste("Furthermore, figure \@ref(fig:siproteins) shows a heatmap of proteins with the FDR < ", grp2$FDRthreshold ," and diff > ",  grp2$log2FCthreshold, ".") ,
paste("Figure \@ref(fig:boxplot) shows the boxplots of ", nrb, " significant proteins."))

```

(ref:siproteins) Heatmap showing proteins with FDR < `r grp2$FDRthreshold` and diff > `r  grp2$log2FCthreshold`.

```{r siproteins, fig.cap="(ref:siproteins)", eval = showSignificant}
sigheat
```


(ref:boxplot) Boxplot of `r nrb` significant proteins.

```{r boxplot, fig.cap="(ref:boxplot)", eval = showSignificant}
gridExtra::grid.arrange(grobs = bp, ncol = 3) 
```



```{r}
existsNoPvalEstimate <- !is.null(grp2$noPvalEstimate)
plotMissing <- if (nrow(grp2$imputedProteins$data) == 0) {
  FALSE
} else { 
  TRUE 
}
  
```

```{r makeTextImputed, eval = plotMissing, results = 'asis' }
cat(paste("Figure \\@ref(fig:imputedProt) shows proteins for which no t-statistic could be estimated, because there are to few observations."))

```


```{r imputedProt, fig.cap = "Proteins with missing value imputation.", fig.height = 10, eval = plotMissing}
grp2$imputedProteins$get_Plotter()$raster()
```

# Data Interpretation

For interpreting the results in the _`r paste0("MaxQuant_report", grp2$projectName, ".xlsx")`_ file, the protein $IDs$ can be either sorted by `log2FC`, `t-statistic` or $sign(log2FC) \cdot` p-value. Large positive or negative fold changes typically result in small p-values.

The IDs sorted by fold change can then be subjected to gene set enrichment analysis (GSEA). Alternatively, a subset filtered by FDR, e.g. for a threshold of $0.1$ or $0.25$, can be analysed using over-representation analysis (ORA). The web application WebGestalt (WEB-based GEne SeT AnaLysis Toolkit) <http://www.webgestalt.org> implements both of these methods for the most popular organisms [@Wang2017]. The [DAVID Bioinformatics Resource](https://david.ncifcrf.gov/home.jsp) also enables you to run ORA analysis for a wide variety of organizms.

Overrepresentation analysis is performed on biological functional categories (e.g., biological processes of gene ontology annotations) or on biological pathways (e.g., KEGG or Wikipathways). Using such methods allows identifying functions or pathways for proteins in the submitted list. For the correct usage and interpretation of the results from such an analysis, it is essential to specify the background proteome. The background proteome is the list of all proteins identified in your experiment.


A further resource to analyze the results is the STRING database <https://string-db.org> [@Szklarczyk2017]. It reports known and predicted interactions for proteins in the submit   ted list.


The FGCZ can support you, with the interpretation of your quantitative proteomics data or with a more customized analysis. Further visualization of the data, targeted to your audience, e.g., receiver operator curves (ROC) or MA-plots, can be generated. You can reach the proteome-bioinformatics team at <protinf@fgcz.uzh.ch>.


\newpage

```{r columnlist, eval=FALSE}
knitr::kable(data.frame(columns=colnames(grp2$getResultTableWithPseudo())), caption="List of column names in result .csv table.")
```


# Disclaimer


The obtained results should be validated orthogonal as well (e.g. with Western blots). The Functional Genomics Center Zurich does not provide any kind of guarantee for the validity of the results.


For questions and improvement suggestions, with respect to this report, please do contact <protinf@fgcz.uzh.ch>.


# Session Inforamtion


```{r sessionInfo}
pander::pander(sessionInfo())
```


# References



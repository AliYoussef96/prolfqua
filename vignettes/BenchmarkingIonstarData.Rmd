---
title: "Benchmarking normalization, aggregation and models using the Ionstar Dataset"
author: "FGCZ - (Draft)"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
papersize: a4
geometry: margin=.5in
vignette: >
  %\VignetteIndexEntry{Benchmarking normalization, aggregation and models using the Ionstar Dataset} 
  %\VignetteEncoding{UTF-8}
  
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---



Please download and install the `prolfquaData` package from github


```{r setup, include=FALSE}
knitr::opts_chunk$set(
echo = TRUE,
message = FALSE,
warning = FALSE,
fig.width = 10,
fig.height = 10
)
```


```{r loadRequiredPackages}
rm(list = ls())
library(conflicted)
library(prolfqua)
library(tidyverse)
library(dplyr)
conflict_prefer("filter", "dplyr")

```


We start by loading the IonStar dataset and the annotation from the `prolfquaData` package. The method `add_annotation` adds the annotation to the data.

```{r loadMQData}
datadir <- file.path(find.package("prolfquaData") , "quantdata")
inputMQfile <-  file.path(datadir,
                          "MAXQuant_IonStar2018_PXD003881.zip")
inputAnnotation <- file.path(datadir, "annotation_Ionstar2018_PXD003881.xlsx")

mqdata <- tidyMQ_Peptides_Config(inputMQfile)
annotation <- readxl::read_xlsx(inputAnnotation)


res <- add_annotation(
  mqdata$data,
  annotation,
  fileName = "raw.file"
)

```

The `setup_analysis` asserts that all columns specified in the configruation are present in the data. For more details about the proflqua configuration see the vignette "Creating Configurations".


```{r annotateData}
mqdata$config$table$factors[["dilution."]] = "sample"
mqdata$config$table$factors[["run_Id"]] = "run_ID"
mqdata$config$table$factorDepth <- 1
mqdata$data <- setup_analysis(res, mqdata$config)

```



```{r filterProteinsByPeptideCount}
datafilt <- prolfqua::filter_proteins_by_peptide_count(mqdata$data, mqdata$config)$data
```


## Data normalization


We will normalize the data using the 'LFQTransformer' class. Since we know that the Human proteins are the Matrix in the experiment we will normalize the data using HUMAN proteins only.
To this task we subset the dataset by filtering for HUMAN proteins only and then use the 'log2_robscale_subset' method.


```{r filterForHumans}

lfqdata <- LFQData$new(datafilt, mqdata$config)
tr <- lfqdata$get_Transformer()

subset_h <- lfqdata$get_copy()
subset_h$data <- subset_h$data %>% filter(grepl("HUMAN", protein_Id))
lfqdataNormalized <- tr$log2_robscale_subset(lfqsubset = subset_h)

```


The figures below show the intensity distribution before and after normalization.

```{r plotIntensityDistributions}

before <- lfqdata$get_Plotter()
before$intensity_distribution_density()

after <- lfqdataNormalized$get_Plotter()
after$intensity_distribution_density()

```


Create a sample of N proteins to speed up computations of models and contrasts.

```{r createDataSubset}
N <- 200
mqdataSubset <- lfqdata$get_sample(size = N, seed = 2020)
lfqNormSubset <- lfqdataNormalized$get_sample(size = N, seed = 2020)
lfqNormSubset$hierarchy_counts()

```





```{r R6Ionstar, echo =  FALSE, include = FALSE}
IonstarData <- R6::R6Class(
  "IonstarData",
  public = list(
    data = NULL,
    config = NULL,
    data_N = NULL,
    config_N = NULL,
    
    initialize = function(data, config, data_N, config_N){
      self$data = data
      self$config = config
      self$data_N = data_N
      self$config_N = config_N
    },
    Pep = function(){
      return(list(data = self$data, config = self$config$clone(deep = TRUE)))
    },
    filtered = function(){
      data <- prolfqua:::filter_proteins_by_peptide_count( self$data ,  self$config )$data
      return(list(data = data, config = self$config$clone(deep = TRUE)))
    },
    normalized = function(){
      return(list(data = self$data_N, config = self$config_N))
    },
    subset_normalized = function(){
      return(list(data = self$data_N, config = self$config_N))
    }
  )
)

ionstar <- IonstarData$new(mqdataSubset$data, mqdataSubset$config, 
                           lfqNormSubset$data, lfqNormSubset$config)

#usethis::use_data(ionstar, overwrite = TRUE)

```


# Infer Protein intensities using Tukeys Median Polish

We will be using the `LFQDataAggregator` class. To estimate protein intensities using Tukey's median polish we need to use normalized data.
The figure below shows the the protein estimates (dashed line) and the peptide intensities used for estimation.

```{r aggregateMedpolish}
lfqAggMedpol <- LFQDataAggregator$new(lfqNormSubset, "protein")
lfqAggMedpol$medpolish()
xx <- lfqAggMedpol$plot()
xx$plots[[1]]
```



```{r storeProteinAggregates, echo = FALSE, include = FALSE}
data_IonstarProtein_subsetNorm <- list(
  data = lfqAggMedpol$lfq_agg$data,
  config = lfqAggMedpol$lfq_agg$config
)

#usethis::use_data(data_IonstarProtein_subsetNorm, overwrite = TRUE)

```

We can also estimate the protein intensities using the top N most abundant peptides. In this case we are using the untransformed protein intensities. The figure below shows the estimated protein intensities.

```{r topNAggregation, echo = TRUE}

lfqAggregator <- LFQDataAggregator$new(mqdataSubset, "protein_topN")
lfqAggregator$mean_topN()
topN <- lfqAggregator$plot()
topN$plots[[1]]

```

# Model Fitting

## Model 1 : Fitting a linear model to the protein intensities


```{r buildModelLM}
protLFQ <- lfqAggMedpol$lfq_agg

lmmodel <- "~ dilution."
lmmodel <- paste0(protLFQ$config$table$getWorkIntensity() , lmmodel)

lfqNormSubset$config$table$hierarchyDepth <- 1
modelFunction <- strategy_lm( lmmodel, model_name = "Model")

modLinearProt <- prolfqua::build_model(protLFQ$data, modelFunction)
modLinearProt$anova_histogram()

```

## Model 2: Fitting a mixed effects model to peptide intensities


```{r buildModelLMer}


lmmodel <- "~ dilution. + (1|peptide_Id) + (1|sampleName)"
lmmodel <- paste0(lfqNormSubset$config$table$getWorkIntensity() , lmmodel)
lfqNormSubset$config$table$hierarchyDepth <- 1
modelFunction <- strategy_lmer( lmmodel, model_name = "Model")
modMixedProtLevel <- prolfqua::build_model(lfqNormSubset$data, modelFunction)
modMixedProtLevel$anova_histogram()

```

## Model 3: Fitting peptide level models

```{r buildModelPeptide}

lmmodel <- "~ dilution."

lfqNormSubset$config$table$hierarchyDepth
lfqNormSubset$config$table$hierarchyDepth <- 2

lmmodel <- paste0(lfqNormSubset$config$table$getWorkIntensity() , lmmodel)

modelFunction <- strategy_lm( lmmodel, model_name = "Model")
modLMPepLevel <- prolfqua::build_model(lfqNormSubset$data,
                                       modelFunction,
                                       subject_Id = lfqNormSubset$subject_id())
modLMPepLevel$anova_histogram()

```


#  Computing Contrasts


```{r defineContrasts}
DEBUG <- FALSE

Contrasts <- c(
  "dilution_(9/3)_3" =   "dilution.e - dilution.a",
  "dilution_(9/4.5)_2" =   "dilution.e - dilution.b",
  "dilution_(9/6)_1.5" =   "dilution.e - dilution.c",
  "dilution_(9/7.5)_1.2" =   "dilution.e - dilution.d",
  
  "dilution_(7.5/3)_2.5" =   "dilution.d - dilution.a",
  "dilution_(7.5/4.5)_1.6(6)" =   "dilution.d - dilution.b",
  "dilution_(7.5/6)_1.25" =   "dilution.d - dilution.c",
  
  "dilution_(6/3)_2" =   "dilution.c - dilution.a",
  "dilution_(6/4.5)_1.3(3)" =   "dilution.c - dilution.b",
  
  "dilution_(4.5/3)_1.5" =   "dilution.b - dilution.a"
)


tt <- Reduce(rbind, strsplit(names(Contrasts),split = "_"))
tt <- data.frame(tt)[,2:3]
colnames(tt) <- c("ratio" , "expected fold-change")
tt <- tibble::add_column(tt, contrast =  Contrasts, .before = 1)
prolfqua::table_facade(tt, caption = "All possible Contrasts given 5 E. coli dilutions of the Ionstar Dataset")

```


```{r usedContrasts}
relevantContrasts <- c("dilution_(9/7.5)_1.2",
                       "dilution_(7.5/6)_1.25",
                       "dilution_(6/4.5)_1.3(3)",
                       "dilution_(4.5/3)_1.5" )

tt <- Reduce(rbind, strsplit(relevantContrasts,split = "_"))
tt <- data.frame(tt)[,2:3]
colnames(tt) <- c("ratio" , "expected fold-change")
tt <- tibble::add_column(tt, contrast =  Contrasts[names(Contrasts) %in% relevantContrasts], .before = 1)
prolfqua::table_facade(tt, caption = "Contrasts used for benchmark.")
relevantContrasts <- Contrasts[names(Contrasts) %in% relevantContrasts]

```


There are four contrasts classes in the package 'Contrast' (uses Wald test), `ContrastModerated` (applies variance moderation), 
`ContrastROPECA` (p-value aggregation), `ContrastSimpleImputed` (contrast computation with p-value imputation using pooled variance to compute t-statistics).


## Contrasts with Imputation

In order to estimate fold-changes, statistics and p-values of proteins for which linear models could not be fitted because of an excess of missing measurements, the following procedure is applied. The mean intensity of a protein over all samples in a condition is computed. For the proteins with no observation in one condition, we imputed their intensities using the mean of the 10% smallest average peptide intensities. The standard deviation is estimated in the condition where the peptide is observed.


```{r contrastImputed}
contrImp <- prolfqua::ContrastsSimpleImpute$new(protLFQ, relevantContrasts)
pl <- contrImp$get_Plotter()
bb <- contrImp$get_contrasts()
contrImp$get_Plotter()$volcano()

```


```{r benchmarkImputed}
ttd <- prolfqua::ionstar_bench_preprocess(contrImp$get_contrasts())

imp_benchmark <- make_benchmark(ttd$data,
                                   model_description = "med. polish and lm. imputation",
                                   model_name = "prot_med_lm_imputation",
                                   FDRvsFDP = list(list(sc = "FDR", desc = FALSE))
)


imp_benchmark$plot_ROC()
imp_benchmark$plot_FDRvsFDP()

```


## Contrasts from Model 1

```{r contrastModel1}
contrProt <- prolfqua::Contrasts$new(modLinearProt, relevantContrasts)
pl <- contrProt$get_Plotter()
pl$volcano()
pl$histogram()
```


```{r benchmarkModel1}
ttd <- prolfqua::ionstar_bench_preprocess(contrProt$get_contrasts())

benchmark_Prot <- make_benchmark(ttd$data,
                                   model_description = "med. polish and lm",
                                   model_name = "prot_med_lm"
)

benchmark_Prot$plot_score_distribution()
benchmark_Prot$plot_FDRvsFDP()

```


### Adding Moderation

```{r contrastModel1Moderation}

contrProtModerated <- ContrastsModerated$new(contrProt)
contrProtModerated$get_Plotter()$volcano()
```


```{r benchmarkModel1Moderation}

ttd <- prolfqua::ionstar_bench_preprocess(contrProtModerated$get_contrasts())

benchmark_ProtModerated <- make_benchmark(ttd$data,
                                   model_description = "med. polish and lm moderated",
                                   model_name = "prot_med_lm_moderated")

benchmark_ProtModerated$plot_score_distribution()
benchmark_ProtModerated$plot_FDRvsFDP()


```

## Contrasts from Model 2

```{r contrastModel2}
contrProtMixed <- prolfqua::Contrasts$new(modMixedProtLevel, relevantContrasts,modelName = "WaldTestMixed")
pl <- contrProtMixed$get_Plotter()
pl$volcano()
pl$histogram()
```


```{r benchmarkModel2}
ttd <- prolfqua::ionstar_bench_preprocess(contrProtMixed$get_contrasts())

benchmark_mixed <- make_benchmark(ttd$data,
                                   model_description = "mixed effect model",
                                   model_name = "prot_mixed_effect"
)

benchmark_mixed$plot_score_distribution()
benchmark_mixed$plot_FDRvsFDP()

```



```{r distributionOfDFModel2, fig.cap="distribution of degrees of freedom for mixed model"}
ctr <- contrProtMixed$get_contrasts()
hist(ctr$df, breaks = 1000, xlim = c(0,100))

```

Since moderation requires a good degrees of freedom estimate 

```{r contrastModel2Moderation}

contrProtMixedModerated <- ContrastsModerated$new(contrProtMixed)
contrProtMixedModerated$get_Plotter()$volcano()
```


```{r benchmarkModel2Moderation}

ttd <- prolfqua::ionstar_bench_preprocess(contrProtMixedModerated$get_contrasts())

benchmark_mixedModerated <- make_benchmark(ttd$data,
                                   model_description = "mixed effect model moderated",
                                   model_name = "prot_mixed_effect_moderated")

benchmark_mixedModerated$plot_score_distribution()
benchmark_mixedModerated$plot_FDRvsFDP()

```


## Protein level Contrasts from Model 3


```{r contrastROPECA}
contrROPECA <- prolfqua::Contrasts$new(modLMPepLevel, relevantContrasts) %>%
  ContrastsModerated$new() %>%
  ContrastsROPECA$new()
contrROPECA$get_Plotter()$volcano()

```


```{r benchmarkROPECA}
ttd <- prolfqua::ionstar_bench_preprocess(contrROPECA$get_contrasts())

benchmark_ropeca <- make_benchmark(ttd$data,
                                toscale = c("beta.based.significance"),
                                benchmark = list(
                                  list(sc = "estimate", desc = TRUE),
                                  list(sc = "statistic", desc = TRUE),
                                  list(sc = "scaled.beta.based.significance", desc = TRUE)
                                ),  
                                model_description = "Ropeca",
                                model_name = "ropeca",
                                FDRvsFDP = list(list(sc = "FDR.beta.based.significance", desc = FALSE))
)

benchmark_ropeca$plot_ROC()
benchmark_ropeca$plot_FDRvsFDP()

```


